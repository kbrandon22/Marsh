#1. Fit the model
#a. Define a function to fit the model
fit_uni_models <- function(model_covs, umf_list){
models <- list()
for(cov in model_covs){
state_formula <- paste("~", cov)
cov_models <- list()
for(i in seq_along(umf_list)){
cov_models[[i]] <- occuMulti(
stateformulas = as.character(rep(state_formula, 10)),
detformulas = as.character(rep("~Effort + Year", 4)),
control = list(maxit = 5000),
maxOrder = 2,
starts = rnorm(32, mean = 0, sd = 0.1),
data = umf_list[[i]]
)
}
models[[cov]] <- cov_models
}
return(models)
}
#b. Apply the function
uni_models <- fit_uni_models(model_covs, umf_list)
uni_models
save(uni_models, file = "Uni_models.Rdata")
#-----
#2. Adjust for overdispersion
#a. Apply the adjustment by specifying c-hat (from global model)
quasi_uni_results <- lapply(uni_models, function(model){
summaryOD(model, c.hat = 1.77, conf.level = 0.95, out.type = "confint")
})
class(uni_models)
class(uni_models[[1]])
class(uni_models[[1]][[1]])
#-----
#2. Adjust for overdispersion
#a. Apply the adjustment by specifying c-hat (from global model)
quasi_uni_results <- lapply(uni_models, function(model_list){
lapply(model_list, function(model){
summaryOD(model, c.hat = 1.77, conf.level = 0.95, out.type = "confint")
})
})
quasi_uni_results
pool_uni <- function(uni_models, quasi_uni_results){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(uni_models)))
par_group <- setNames(uni_models[grep(paste0("^", cov_name), names(uni_models))])
flatten_list <- unlist(quasi_uni_models, recursive = TRUE)
for(cov in names(par_group)){
model_list <- flatten_list(par_group[[cov]])
model_list <- model_list[sapply(model_list, inherits, "unmarkedFitOccuMulti")]
uni_results[[cov]] <- pool_quasi(model_list)
}
}
uni_results <- pool_uni(uni_models, quasi_uni_results)
uni_results <- pool_uni(quasi_uni_results)
pool_uni <- function(uni_models, quasi_uni_results){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(uni_models)))
par_group <- setNames(lapply(cov_name, function(cov){
uni_models[grep(paste0("^", cov), names(uni_models))]
}), cov_name)
flatten_list <- function(x){
unlist(x, recursive = TRUE)
}
for(cov in names(par_group)){
model_list <- flatten_list(par_group[[cov]])
model_list <- model_list[sapply(model_list, inherits, "unmarkedFitOccuMulti")]
uni_results[[cov]] <- pool_quasi(model_list)
}
return(results)
}
uni_results <- pool_uni(uni_models, quasi_uni_models)
quasi_uni_list <- unlist(quasi_uni_results, recursive = FALSE)
quasi_uni_list
pool_uni <- function(uni_models, quasi_uni_results){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(uni_models)))
par_group <- setNames(lapply(cov_name, function(cov){
uni_models[grep(paste0("^", cov), names(uni_models))]
}), cov_name)
flatten_list <- function(x){
unlist(x, recursive = TRUE)
}
for(cov in names(par_group)){
model_list <- flatten_list(par_group[[cov]])
model_list <- model_list[sapply(model_list, inherits, "unmarkedFitOccuMulti")]
uni_results[[cov]] <- pool_quasi(model_list)
}
return(results)
}
uni_results <- pool_uni(uni_models, quasi_uni_models)
class(quasi_uni_list)
class(quasi_uni_list[[1]])
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(uni_models){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(uni_models)))
par_group <- setNames(lapply(cov_name, function(cov){
uni_models[grep(paste0("^", cov), names(uni_models))]
}), cov_name)
flatten_list <- function(x){
unlist(x, recursive = TRUE)
}
for(cov in names(par_group)){
model_list <- flatten_list(par_group[[cov]])
model_list <- model_list[sapply(model_list, inherits, "unmarkedFitOccuMulti")]
uni_results[[cov]] <- pool_quasi(model_list)
}
return(results)
}
#3) Apply the function
uni_results <- pool_uni(uni_models, quasi_uni_models)
#3) Apply the function
uni_results <- pool_uni(uni_models)
quasi_uni_list
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list, pool_quasi){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
flatten_list <- function(x){
unlist(x, recursive = TRUE)
}
for(cov in names(par_group)){
model_list <- flatten_list(par_group[[cov]])
model_list <- model_list[sapply(model_list, inherits, "unmarkedFitOccuMulti")]
uni_results[[cov]] <- pool_quasi(model_list)
}
return(results)
}
#3) Apply the function
uni_results <- pool_uni(quasi_uni_list, pool_quasi)
#3) Apply the function
uni_results <- pool_uni(quasi_uni_list)
class(quasi_uni_list[[1]])
global_pen_models[[1]]
#-----
#4. Assess goodness-of-fit on model residuals
#a. Flatten the list of models
global_models_flat <- unlist(global_pen_models, recursive = FALSE)
#b. Initiate parallel computing
cl <- makeCluster(detectCores() - 1)
clusterExport(cl, c("global_models_flat", "fitstats"))
global_pen_models[[1]]
global_pen_models
class(global_pen_models)
class(global_pen_models[[1]])
#-----
#4. Assess goodness-of-fit on model residuals
#a. Flatten the list of models
global_models_flat <- unlist(global_pen_models, recursive = FALSE)
load("GOF_global_pen_models.Rdata")
#e. Pool the results
global_fit_pooled <- pool_fitstats(global_pen_fit)
#-----
#5. Account for overdispersion with quasi-likelihood adjustment
#a. Apply the adjustment by specifying c-hat
quasi_global_results <- lapply(global_pen_models, function(model){
summaryOD(model, c.hat = 1.77, conf.level = 0.95, out.type = "confint")
})
quasi_global_results
class(quasi_global_results)
class(quasi_global_results[[1]])
#b. Pool the results with Rubin's rules
pooled_global_quasi_results <- pool_quasi(quasi_global_results)
pooled_global_quasi_results
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list, pool_quasi){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
flatten_list <- function(x){
unlist(x, recursive = TRUE)
}
for(cov in names(par_group)){
model_list <- flatten_list(par_group[[cov]])
}
return(results)
}
uni <- pool_uni(quasi_uni_list)
uni
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list, pool_quasi){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
flatten_list <- function(x){
unlist(x, recursive = TRUE)
}
for(cov in names(par_group)){
model_list <- flatten_list(par_group[[cov]])
results[[cov]] <- model_list
}
return(results)
}
uni <- pool_uni(quasi_uni_list)
uni
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list, pool_quasi){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
flatten_list <- function(x){
unlist(x, recursive = TRUE)
}
for(cov in names(par_group)){
model_list <- flatten_list(par_group[[cov]])
model_list <- model_list[sapply(model_list, inherits, "unmarkedFitOccuMulti")]
results[[cov]] <- model_list
}
return(results)
}
uni <- pool_uni(quasi_uni_list)
uni
uni
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list, pool_quasi){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
results[[cov]] <- par_group
return(results)
}
uni <- pool_uni(quasi_uni_list)
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list, pool_quasi){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
results[[cov]] <- par_group[[cov]]
return(results)
}
uni <- pool_uni(quasi_uni_list)
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
results[[cov_name]] <- par_group[[cov_name]]
return(results)
}
uni <- pool_uni(quasi_uni_list)
results[[cov_name]] <- par_group
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
results[[cov_name]] <- par_group
return(results)
}
uni <- pool_uni(quasi_uni_list)
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list, pool_quasi){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
results <- par_group
return(results)
}
uni <- pool_uni(quasi_uni_list)
uni
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
results <- par_group
return(results)
}
uni <- pool_uni(quasi_uni_list)
uni
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list, pool_quasi){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
flatten_list <- function(x){
unlist(x, recursive = TRUE)
}
for(cov in names(par_group)){
model_list <- flatten_list(par_group[[cov]])
results[[cov]] <- str(model_list)
}
return(results)
}
uni <- pool_uni(quasi_uni_list)
quasi_uni_list
#2) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list, pool_quasi){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
flatten_list <- function(x){
unlist(x, recursive = TRUE)
}
for(cov in names(par_group)){
model_list <- flatten_list(par_group[[cov]])
model_list <- model_list[sapply(model_list, inherits, "unmarkedFitOccuMulti")]
results[[cov]] <- pool_quasi(model_list)
}
return(results)
}
#3) Apply the function
uni_results <- pool_uni(quasi_uni_list, pool_quasi)
class(quasi_uni_results)
class(quasi_uni_results[[1]])
class(quasi_uni_results[[1]][[1]])
#b. Pool the results with Rubin's rules
#1) Define a function to group and pool outputs by independent variable
pool_uni <- function(quasi_uni_list, pool_quasi){
results <- list()
cov_name <- unique(sub("\\d+$", "", names(quasi_uni_list)))
par_group <- setNames(lapply(cov_name, function(cov){
quasi_uni_list[grep(paste0("^", cov), names(quasi_uni_list))]
}), cov_name)
for(cov in names(par_group)){
cov_data <- par_group[[cov]]
pooled_results <- pool_quasi(cov_data)
results[[cov]] <- pooled_results
}
return(results)
}
#2) Apply the function
uni_results <- pool_uni(quasi_uni_list, pool_quasi)
uni_results
#1. Create a list of bivariate combinations from the vector of independent variables
bi_combos <- combinat::combn(model_covs, 2, simplify = FALSE)
#-----
#2. Fit the models
#a.  Define a function to fit the model
fit_bi_models <- function(bi_combos, umf_list){
models <- list()
for(combo in bi_combos){
state_formula <- paste("~", paste(combo,  collapse = "+"))
combo_name <- paste(combo, collapse = "+")
cov_models <- list()
for(i in seq_along(umf_list)){
cov_models[[i]] <- occuMulti(
stateformulas = as.character(rep(state_formula, 4)),
detformulas = as.character(rep("~Effort + Year", 4)),
control = list(maxit = 5000),
maxOrder = 1,
starts = rnorm(44, mean = 0, sd = 0.1),
data = umf_list[[i]]
)
}
models[[combo_name]] <- cov_models
}
return(models)
}
#b. Apply the function
bi_models <- fit_bi_models(bi_combos, umf_list)
bi_models
#-----
#2. Fit the models
#a.  Define a function to fit the model
fit_bi_models <- function(bi_combos, umf_list){
models <- list()
for(combo in bi_combos){
state_formula <- paste("~", paste(combo,  collapse = "+"))
combo_name <- paste(combo, collapse = "+")
cov_models <- list()
for(i in seq_along(umf_list)){
cov_models[[i]] <- occuMulti(
stateformulas = as.character(rep(state_formula, 10)),
detformulas = as.character(rep("~Effort + Year", 4)),
control = list(maxit = 5000),
maxOrder = 2,
starts = rnorm(44, mean = 0, sd = 0.1),
data = umf_list[[i]]
)
}
models[[combo_name]] <- cov_models
}
return(models)
}
#b. Apply the function
bi_models <- fit_bi_models(bi_combos, umf_list)
#-----
#2. Fit the models
#a.  Define a function to fit the model
fit_bi_models <- function(bi_combos, umf_list){
models <- list()
for(combo in bi_combos){
state_formula <- paste("~", paste(combo,  collapse = "+"))
combo_name <- paste(combo, collapse = "+")
cov_models <- list()
for(i in seq_along(umf_list)){
cov_models[[i]] <- occuMulti(
stateformulas = as.character(rep(state_formula, 10)),
detformulas = as.character(rep("~Effort + Year", 4)),
control = list(maxit = 5000),
maxOrder = 2,
starts = rnorm(42, mean = 0, sd = 0.1),
data = umf_list[[i]]
)
}
models[[combo_name]] <- cov_models
}
return(models)
}
#b. Apply the function
bi_models <- fit_bi_models(bi_combos, umf_list)
bi_models
#-----
#2. Fit the models
#a.  Define a function to fit the model
fit_bi_models <- function(bi_combos, umf_list){
models <- list()
for(combo in bi_combos){
state_formula <- paste("~", paste(combo,  collapse = "+"))
combo_name <- paste(combo, collapse = "+")
cov_models <- list()
for(i in seq_along(umf_list)){
cov_models[[i]] <- occuMulti(
stateformulas = as.character(rep(state_formula, 10)),
detformulas = as.character(rep("~Effort + Year", 4)),
control = list(maxit = 5000),
maxOrder = 2,
starts = rnorm(42, mean = 0, sd = 0.08),
data = umf_list[[i]]
)
}
models[[combo_name]] <- cov_models
}
return(models)
}
#b. Apply the function
bi_models <- fit_bi_models(bi_combos, umf_list)
bi_models
#1. Configure GIT
use_git_config(user.name = "Kristin Brandon")
library(usethis)
#1. Configure GIT
use_git_config(user.name = "Kristin Brandon")
#1. Configure GIT
use_git_config(user.name = "Kristin Brandon", user.email = "kbrandon@suisunrcd.org")
use_git()
#1. Configure GIT
use_git_config(user.name = "kbrandon22", user.email = "kbrandon@suisunrcd.org")
use_git()
#1. Configure GIT
use_git_config(user.name = "kbrandon22", user.email = "kristin.brandon22@gmail.com")
use_git()
here::dr_here()
install.packages("here")
library(here)
here::dr_here()
system("git --version")
which git
which(git)
git--version
system("git--version")
system("which git")
system("whichgit")
system("git update-git-for-windows")
1
system("git update-git-for-windows")
#1. Configure GIT
use_git_config(user.name = "kbrandon22", user.email = "kristin.brandon22@gmail.com")
use_git()
`git --version`
git --version
git--version
'git --version'
`git --version`
system("whichgit")
system("which git")
system("git --version")
use_git()
#1. Set seed for reproducibility
set.seed(500)
#2. Set working directory
setwd("C:\\Users\\Kristin\\Documents\\Multispecies Occupancy\\Data Analysis\\R code\\Occupancy Models\\Marsh")
#3. Configure Git
use_git_config(user.name = "kbrandon22", user.email = "kristin.brandon22@gmail.com")
use_git()
getwd()
proj_get()
#1. Read and manage csv files
rodent_df <- read.csv("Marsh Master Spreadsheet R.csv") %>%
dplyr::select(Location, Longitude, Latitude, Type, Area, Dist_urban, Above_MHW, Mcal_conn,
Mmus_conn, Rrav_conn, Rmeg_conn, Effort, Year) %>%
mutate(Year = as.factor(ifelse(Year == 2021, 0, 1)),                   #Create a dummy variable for year
Effort = as.numeric(Effort))
use_git()
