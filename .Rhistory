#2. Fit logistic regression models to evaluate transformations
#a. Define the dependent variables, extracting occupancy values for each species
occ_var <- "Occupancy"
species_list <- unique(rodent_imp[[1]]$Species)
dep_vars <- list()
for(species in species_list){
species_data <- rodent_imp[[1]] %>%
filter(Species == species)
occupancy <- species_data[[occ_var]]
dep_vars[[species]] <- occupancy
}
#b. Define the independent variables
covs <- c("Area", "Dist_urban", "Above_MHW", "Connectivity")
#c. Define the transformations
transformations <- c("linear", "log")
#d. Define a function to calculate shifted covariate values for log transformations (log(x), x>0)
calc_shift <- function(data, covariate) {
min_value <- min(data[[covariate]], na.rm = TRUE)
if (min_value <= 0) abs(min_value) + 0.01 else 0
}
#e. Define another function to dynamically apply the transformations and assess best fit with AIC
transform_covs <- function(rodent_imp, dep_vars, covs, transformations) {
pooled_results <- list()
for (species_name in dep_vars){
species_results <- list()
for (cov in covs) {
#Calculate shifted covariate values for transformations
shift_value <- calc_shift(do.call(rbind, rodent_imp), cov)
#Initialize data frame to store pooled AIC results
pooled_aic <- data.frame(
Transformation = character(),
AIC = numeric(),
stringsAsFactors = FALSE)
for (trans in transformations) {
aic_values <- c()
for (imp in rodent_imp) {
transformed_data <- imp
species_data <- transformed_data %>%
filter(Species == species_name)
#Apply transformations
if (trans == "log") {
species_data <- species_data %>%
mutate(!!sym(cov) := log(!!sym(cov) + shift_value))
} else if (trans == "linear"){
species_data <- species_data
}
#Fit the linear models and extract AIC values
formula <- as.formula(paste("Occupancy ~", cov))
model <- glm(formula, data = species_data, family = binomial)
aic_values <- c(aic_values, AIC(model))
}
#Pool AIC values using Rubin's rules
mean_aic <- mean(aic_values)
var_aic <- var(aic_values)
pooled_aic_value <- mean_aic + (var_aic / length(aic_values))
pooled_aic <- rbind(pooled_aic, data.frame(
Transformation = trans,
AIC = pooled_aic_value
)) %>% arrange(AIC)
}
#Calculate delta AIC <=2
best_aic <- min(pooled_aic$AIC)
pooled_aic$Delta_AIC <- pooled_aic$AIC - best_aic
species_results[[cov]] <- pooled_aic
}
pooled_results[[species_name]] <- species_results
}
return(pooled_results)
}
#1) Apply the function
pooled_results <- transform_covs(
rodent_imp = rodent_imp,
dep_vars = unique(rodent_imp[[1]]$Species),
covs = covs,
transformations = transformations
)
pooled_results
####################KEEP, EXCLUDE TRANSFORM#########################
#f. Scale and transform independent variables (as needed)
scale_transform <- function(rodent_imp){
transformed_data <- lapply(rodent_imp, function(data){
data <- data %>%
mutate(Log_Area = log(Area))
covs <- c("Area", "Log_Area", "Dist_urban", "Above_MHW", "Connectivity", "Effort")
data <- data %>%
mutate(across(all_of(covs),~as.vector(scale(.)))) %>%
dplyr::select(Location, Longitude, Latitude, Surveyor, Species, Occupancy, Type,
Area, Log_Area, Dist_urban, Above_MHW, Connectivity, Effort, Year,
matches("^Rrav_[1-9]$|^Rrav_1[0-9]$|^Rrav_20$"), matches("^Rmeg_[1-9]$|^Rmeg_1[0-9]$|^Rmeg_20$"),
matches("^Mmus_[1-9]$|^Mmus_1[0-9]$|^Mmus_20$"), matches("^Mcal_[1-9]$|^Mcal_1[0-9]$|^Mcal_20$"))
return(data)
})
return(transformed_data)
}
rodent_imp <- scale_transform(rodent_imp)
rodent_imp[[1]]
#g. Plot log-transformed variables
#1) Assess non-linearity assumption violation
ggplot(rodent_imp[[1]], aes(x = Log_Area, y = Occupancy)) +
geom_point(position = position_jitter(height = 0.1), alpha = 0.3) +
geom_smooth(method = "loess", color = "pink", se = FALSE) +
facet_wrap(~ Species) +
labs(title = "Occupancy vs Log Patch Area",
x = "Log Patch Area",
y = "Occupancy Probability") +
theme_minimal()
#2) Assess normality (not a strict assumption of MSOMs)
hist(rodent_imp[[1]]$Area, main = "Area Distribution", xlab = "Area", col = "lightblue")
hist(rodent_imp[[1]]$Log_Area, main = "Log Area Distribution", xlab = "Log Area", col = "lightblue")
qqnorm(rodent_imp[[1]]$Area)
qqnorm(rodent_imp[[1]]$Log_Area)
#----------
#3. Check for collinearity among continuous independent variables using variance inflation factor (VIF)
vif_results <- list()
for(species in species_list){
dep_var <- dep_vars[[species]]
dep_vif <- list()
for(i in seq_along(rodent_imp)){
species_data <- rodent_imp[[i]] %>%
filter(Species == species)
species_data$dep_var <- rep(dep_var, nrow(species_data)/length(dep_var))
formula <- as.formula(paste("dep_var ~", paste(covs, collapse = "+")))
model <- lm(formula, data = species_data)
vif_values <- car::vif(model)
dep_vif[[i]] <- vif_values
}
vif_results[[species]] <- dep_vif
}
vif_results
#----------
#4. Explore non-additive effects of interactions
#a. Connectivity*area (connectivity may enhance occupancy in smaller marshes)
#1) Fit the linear models to evaluate the interaction
#a) Define a function to fit the linear models
fit_conn_area_models <- function(rodent_imp) {
models_list <- list()
for (i in seq_along(rodent_imp)) {
data <- rodent_imp[[i]]
model <- lm(Connectivity ~ Area + Area:Connectivity, data = data)
models_list[[i]] <- model
}
return(models_list)
}
#b) Apply the function and view results
conn_area_models <- fit_conn_area_models(rodent_imp)
conn_area_models
#2) Extract fitted model predictions and coefficients and combine into data frames
preds_coefs <- lapply(seq_along(conn_area_models), function(i){
model <- conn_area_models[[i]]
coefs <- tidy(model) %>%
filter(term == "Connectivity:Area") %>%
mutate(imp = i)
preds <- predict(model, newdata = rodent_imp[[i]], type = "response")
pred_data <- rodent_imp[[i]] %>%
mutate(prediction = preds)
return(list(coefs = coefs, preds = pred_data))
})
preds_df <- bind_rows(lapply(preds_coefs, `[[`, "preds"))
coefs_df <- bind_rows(lapply(preds_coefs, `[[`, "coefs"))
coefs_df
#3) Visualize the interaction as it relates to occupancy, holding one covariate constant
#a) Fit the linear model to the list of imputed data sets
conn_area_models1 <- lapply(species_list, function(species){
lapply(rodent_imp, function(data){
species_data <- subset(data, Species == species)
formula <- as.formula("Occupancy ~ Connectivity*Area")
model <- lm(formula, data = species_data)
return(model)
})
})
names(conn_area_models1) <- species_list
conn_area_models1
#b) Generate a prediction grid for each covariate, fixing the other variable at its mean
area_grid <- lapply(seq_along(rodent_imp), function(i){
data <- rodent_imp[[i]]
grid <- expand.grid(
Area = seq(min(data$Area), max(data$Area), length.out = 100),
Connectivity = mean(data$Connectivity)
)
return(grid)
})
conn_grid <- lapply(seq_along(rodent_imp), function(i){
data <- rodent_imp[[i]]
grid <- expand.grid(
Area = mean(data$Area),
Connectivity = seq(min(data$Connectivity), max(data$Connectivity), length.out = 100)
)
return(grid)
})
#c) Predict occupancy for each covariate
area_preds <- lapply(seq_along(rodent_imp), function(i){
lapply(seq_along(conn_area_models1), function(j){
model <- conn_area_models1[[j]][[i]]
preds <- predict(model, newdata = area_grid[[i]], type = "response")
pred_grid <- cbind(area_grid[[i]], Prediction = preds,
Variable = "Area", Imp = i, Species = species_list[j])
return(pred_grid)
})
})
conn_preds <- lapply(seq_along(rodent_imp), function(i){
lapply(seq_along(conn_area_models1), function(j){
model <- conn_area_models1[[j]][[i]]
preds <- predict(model, newdata = conn_grid[[i]], type = "response")
species_name <- names(conn_area_models1[[j]])[1]
pred_grid <- cbind(conn_grid[[i]], Prediction = preds,
Variable = "Connectivity", Imp = i, Species = species_list[j])
return(pred_grid)
})
})
#d) Summarize predictions and combine into a data frame
area_preds_df <- do.call(rbind, lapply(seq_along(area_preds), function(i){
do.call(rbind, lapply(seq_along(area_preds[[i]]), function(j){
area_preds[[i]][[j]] %>%
group_by(Area, Connectivity, Imp, Species, Variable) %>%
summarize(Prediction = mean(Prediction), .groups = "drop")
}))
}))
area_preds_df
conn_preds_df <- do.call(rbind, lapply(seq_along(conn_preds), function(i){
do.call(rbind, lapply(seq_along(conn_preds[[i]]), function(j){
conn_preds[[i]][[j]] %>%
group_by(Area, Connectivity, Imp, Species, Variable) %>%
summarize(Prediction = mean(Prediction), .groups = "drop")
}))
}))
#e) Combine the grids and add a column for species name
plot_data <- rbind(area_preds_df, conn_preds_df)
plot_data
#f) Plot the interaction
ggplot(plot_data, aes(x = ifelse(Variable == "Area", Area, Connectivity),
y = Prediction, color = Variable)) +
geom_line() +
labs(x = "Covariate value", y = "Predicted occupancy", color = "Variable") +
theme_minimal() +
facet_wrap(Imp~Species, scales = "free_x", nrow = 10, ncol = 4) +
theme(strip.text = element_text(size = 8),
panel.spacing = unit(1, "lines"))
#1. Create detection/non-detection matrices
#a. Extract detection data for each species
Rrav <- rodent_imp[[1]] %>%
dplyr::select(matches("^Rrav_[1-9]$|^Rrav_1[0-9]$|^Rrav_20$"))
Rrav <- as.matrix(Rrav)
Rmeg <- rodent_imp[[1]] %>%
dplyr::select(matches("^Rmeg_[1-9]$|^Rmeg_1[0-9]$|^Rmeg_20$"))
Rmeg <- as.matrix(Rmeg)
Mmus <- rodent_imp[[1]] %>%
dplyr::select(matches("^Mmus_[1-9]$|^Mmus_1[0-9]$|^Mmus_20$"))
Mmus <- as.matrix(Mmus)
Mcal <- rodent_imp[[1]] %>%
dplyr::select(matches("^Mcal_[1-9]$|^Mcal_1[0-9]$|^Mcal_20$"))
Mcal <- as.matrix(Mcal)
#-----
#2. Create data frame of standardized independent variables
#a. Extract variable names
covs <- colnames(rodent_imp[[1]])
covs
covs <- covs[c(7:9, 10:14)]        #Edit to include log_area if needed
#b. Define a function to extract variables and convert characters to factor
extract_covs <- function(data, scale_covs){
covariate_df <- data[, covs, drop = FALSE]
covariate_df[] <- lapply(names(covariate_df), function(colname) {
col <- covariate_df[[colname]]
if (is.character(col)) {
as.factor(col)
} else {
col
}
})
return(covariate_df)
}
#c. Apply the function to each imputed data set
sitecovs <- lapply(rodent_imp, extract_covs)
str(sitecovs)
#----------
#3. Create unmarkedFrameOccuMulti objects
#a. Rrav
#1) Define a function to create the umf objects
create_umf_rrav <- function(Rrav, site_covs) {
umf_list_rrav <- list()
for (i in 1:length(site_covs)) {
umf_list_rrav[[i]] <- unmarkedFrameOccu(
y = Rrav,
siteCovs = site_covs[[i]]
)
}
return(umf_list_rrav)
}
#2) Apply the function to create a list of umf objects (one for each dataset)
umf_list_rrav <- create_umf_rrav(Rrav, sitecovs)
summary(umf_list_rrav[[1]])
str(umf_list_rrav[[1]]@siteCovs)
plot(umf_list_rrav[[1]])
#b. Rmeg
#1) Define a function to create the umf objects
create_umf_rmeg <- function(Rmeg, site_covs) {
umf_list_rmeg <- list()
for (i in 1:length(site_covs)) {
umf_list_rmeg[[i]] <- unmarkedFrameOccu(
y = Rmeg,
siteCovs = site_covs[[i]]
)
}
return(umf_list_rmeg)
}
#2) Apply the function to create a list of umf objects (one for each dataset)
umf_list_rmeg <- create_umf_rmeg(Rmeg, sitecovs)
summary(umf_list_rmeg[[1]])
plot(umf_list_rmeg[[1]])
#c. Mmus
#1) Define a function to create the umf objects
create_umf_mmus <- function(Mmus, site_covs) {
umf_list_mmus <- list()
for (i in 1:length(site_covs)) {
umf_list_mmus[[i]] <- unmarkedFrameOccu(
y = Mmus,
siteCovs = site_covs[[i]]
)
}
return(umf_list_mmus)
}
#2) Apply the function to create a list of umf objects (one for each dataset)
umf_list_mmus <- create_umf_mmus(Mmus, sitecovs)
summary(umf_list_mmus[[1]])
plot(umf_list_mmus[[1]])
#d. Mcal
#1) Define a function to create the umf objects
create_umf_mcal <- function(Mcal, site_covs) {
umf_list_mcal <- list()
for (i in 1:length(site_covs)) {
umf_list_mcal[[i]] <- unmarkedFrameOccu(
y = Mcal,
siteCovs = site_covs[[i]]
)
}
return(umf_list_mcal)
}
#2) Apply the function to create a list of umf objects (one for each dataset)
umf_list_mcal <- create_umf_mcal(Mcal, sitecovs)
summary(umf_list_mcal[[1]])
plot(umf_list_mcal[[1]])
#1. Define the independent variables
model_covs <- c("Log_Area", "Dist_urban", "Above_MHW", "Connectivity", "Connectivity:Area")
#-----
#2. Fit the models
#a. Rrav
#1) Define a function to fit the model
fit_global_models_rrav <- function(umf_list_rrav){
model_list <- list()
state_formula <- paste("~", paste(model_covs, collapse = "+"))
det_formula <- c("~Effort + Year")
for(i in seq_along(umf_list_rrav)){
model_list[[i]] <- occu(
formula = as.formula(paste(det_formula, "~", state_formula)),
control = list(maxit = 5000),
data = umf_list_rrav[[i]]
)
}
return(model_list)
}
#2) Apply the function
global_models_rrav <- fit_global_models_rrav(umf_list_rrav)
summary(global_models_rrav[[1]])
#b. Rmeg
#1) Define a function to fit the model
fit_global_models_rmeg <- function(umf_list_rmeg){
model_list <- list()
state_formula <- paste("~", paste(model_covs, collapse = "+"))
det_formula <- c("~Effort + Year")
for(i in seq_along(umf_list_rmeg)){
model_list[[i]] <- occu(
formula = as.formula(paste(det_formula, "~", state_formula)),
control = list(maxit = 5000),
data = umf_list_rmeg[[i]]
)
}
return(model_list)
}
#2) Apply the function
global_models_rmeg <- fit_global_models_rmeg(umf_list_rmeg)
summary(global_models_rmeg[[1]])
#c. Mmus
#1) Define a function to fit the model
fit_global_models_mmus <- function(umf_list_mmus){
model_list <- list()
state_formula <- paste("~", paste(model_covs, collapse = "+"))
det_formula <- c("~Effort + Year")
for(i in seq_along(umf_list_mmus)){
model_list[[i]] <- occu(
formula = as.formula(paste(det_formula, "~", state_formula)),
control = list(maxit = 5000),
data = umf_list_mmus[[i]]
)
}
return(model_list)
}
#2) Apply the function
global_models_mmus <- fit_global_models_mmus(umf_list_mmus)
summary(global_models_mmus[[1]])
#d. Mcal
#1) Define a function to fit the model
fit_global_models_mcal <- function(umf_list_mcal){
model_list <- list()
state_formula <- paste("~", paste(model_covs, collapse = "+"))
det_formula <- c("~Effort + Year")
for(i in seq_along(umf_list_mcal)){
model_list[[i]] <- occu(
formula = as.formula(paste(det_formula, "~", state_formula)),
control = list(maxit = 5000),
data = umf_list_mcal[[i]]
)
}
return(model_list)
}
#2) Apply the function
global_models_mcal <- fit_global_models_mcal(umf_list_mcal)
summary(global_models_mcal[[1]])
#-----
#3. Assess goodness-of-fit on model residuals
#a. Rrav
#1) Flatten the list of models
global_models_rrav_flat <- unlist(global_models_rrav, recursive = FALSE)
#2) Calculate fit statistis
rrav_global_gof <- lapply(global_models_rrav_flat, function(model){
mb.gof.test(model, nsim = 100, plot.hist = FALSE)
})
rrav_global_gof
#1. Define the independent variables
model_covs <- c("Log_Area", "Dist_urban", "Above_MHW", "Connectivity", "Connectivity:Log_Area")
#-----
#2. Fit the models
#a. Rrav
#1) Define a function to fit the model
fit_global_models_rrav <- function(umf_list_rrav){
model_list <- list()
state_formula <- paste("~", paste(model_covs, collapse = "+"))
det_formula <- c("~Effort + Year")
for(i in seq_along(umf_list_rrav)){
model_list[[i]] <- occu(
formula = as.formula(paste(det_formula, "~", state_formula)),
control = list(maxit = 5000),
data = umf_list_rrav[[i]]
)
}
return(model_list)
}
#2) Apply the function
global_models_rrav <- fit_global_models_rrav(umf_list_rrav)
summary(global_models_rrav[[1]])
#b. Rmeg
#1) Define a function to fit the model
fit_global_models_rmeg <- function(umf_list_rmeg){
model_list <- list()
state_formula <- paste("~", paste(model_covs, collapse = "+"))
det_formula <- c("~Effort + Year")
for(i in seq_along(umf_list_rmeg)){
model_list[[i]] <- occu(
formula = as.formula(paste(det_formula, "~", state_formula)),
control = list(maxit = 5000),
data = umf_list_rmeg[[i]]
)
}
return(model_list)
}
#2) Apply the function
global_models_rmeg <- fit_global_models_rmeg(umf_list_rmeg)
summary(global_models_rmeg[[1]])
#c. Mmus
#1) Define a function to fit the model
fit_global_models_mmus <- function(umf_list_mmus){
model_list <- list()
state_formula <- paste("~", paste(model_covs, collapse = "+"))
det_formula <- c("~Effort + Year")
for(i in seq_along(umf_list_mmus)){
model_list[[i]] <- occu(
formula = as.formula(paste(det_formula, "~", state_formula)),
control = list(maxit = 5000),
data = umf_list_mmus[[i]]
)
}
return(model_list)
}
#2) Apply the function
global_models_mmus <- fit_global_models_mmus(umf_list_mmus)
summary(global_models_mmus[[1]])
#d. Mcal
#1) Define a function to fit the model
fit_global_models_mcal <- function(umf_list_mcal){
model_list <- list()
state_formula <- paste("~", paste(model_covs, collapse = "+"))
det_formula <- c("~Effort + Year")
for(i in seq_along(umf_list_mcal)){
model_list[[i]] <- occu(
formula = as.formula(paste(det_formula, "~", state_formula)),
control = list(maxit = 5000),
data = umf_list_mcal[[i]]
)
}
return(model_list)
}
#2) Apply the function
global_models_mcal <- fit_global_models_mcal(umf_list_mcal)
summary(global_models_mcal[[1]])
#-----
#3. Assess goodness-of-fit on model residuals
#a. Rrav
#1) Flatten the list of models
global_models_rrav_flat <- unlist(global_models_rrav, recursive = FALSE)
#2) Calculate fit statistis
rrav_global_gof <- lapply(global_models_rrav_flat, function(model){
mb.gof.test(model, nsim = 100, plot.hist = FALSE)
})
rrav_global_gof
